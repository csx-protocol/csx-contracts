//SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.17;

import "../Keepers/IKeepers.sol";
import "../Users/IUsers.sol";
import "../TradeFactory/ITradeFactory.sol";
import "../utils/Strings.sol";

contract Trade {
    event BuyerCommitted(
        string sellerTradeUrl,
        string buyerTradeUrl,
        string assetId
    );

    event StatusChange(
        address contractAdress,
        TradeStatus newStatus,
        string data
    );

    address payable public seller;
    address payable public buyer;

    string public itemMarketName;
    string public itemSellerAssetId;
    string public sellerTradeUrl; //Divide tradeUrls into PartnerId & Token

    string public sellerPartnerId;
    string public sellerTradeToken;

    string public inspectLink;
    string public itemImageUrl;

    uint256 public buyerDeposited;
    uint256 public weiPrice;
    uint256 public buyerCommittedTimestamp;

    FloatInfo public float;

    TradeStatus public status;

    IKeepers public keepersContract;
    IUsers public usersContract;
    ITradeFactory public factoryContract;

    string public disputeComplaint;
    TradeStatus public disputedStatus;
    address public disputeer;

    constructor(
        address _factory,
        address _keepers,
        address _users,
        address _seller,
        uint256 _weiPrice,
        string memory _itemMarketName,
        string memory _sellerTradeUrl,
        string memory _sellerAssetId,
        string memory _inspectLink,
        string memory _itemImageUrl,
        FloatInfo memory _float
    ) {
        factoryContract = ITradeFactory(_factory);
        keepersContract = IKeepers(_keepers);
        usersContract = IUsers(_users);
        seller = payable(_seller);
        weiPrice = _weiPrice;
        status = TradeStatus.Pending;
        itemMarketName = _itemMarketName;
        sellerTradeUrl = _sellerTradeUrl;
        itemSellerAssetId = _sellerAssetId;
        inspectLink = _inspectLink;
        itemImageUrl = _itemImageUrl;
        float.value = _float.value;
        float.min = _float.min;
        float.max = _float.max;
    }

    modifier onlyAddress(address _address) {
        require(msg.sender == _address, "Incorrect party.");
        _;
    }

    modifier onlyTheseAddresses(address _add1, address _add2) {
        require(msg.sender == _add1 || msg.sender == _add2, "Incorrect group.");
        _;
    }

    modifier onlyKeeperNode() {
        require(keepersContract.isKeeperNode(msg.sender));
        _;
    }

    modifier onlyKeepersOrNode() {
        require(
            keepersContract.isKeeperNode(msg.sender) ||
                keepersContract.indexOf(msg.sender) != 0,
            "not keeper or oracle"
        );
        _;
    }

    // Seller can cancel the listing before any buyer has committed ETH.
    function sellerCancel() external onlyAddress(seller) {
        require(status == TradeStatus.Pending, "status not pending");
        status = TradeStatus.SellerCancelled;
        factoryContract.onStatusChange(status, "");
        //emit StatusChange(address(this), status, '');
    }

    // Buyer commits ETH to buy if status-state allows & Sends trade-offer to sellers trade-link off-chain.
    function commitBuy(string memory buyerTradeUrl) public payable {
        require(status == TradeStatus.Pending, "Trade Status not pending.");
        require(msg.value >= weiPrice, "Insufficient ether sent by the buyer.");
        status = TradeStatus.Committed;
        usersContract.startDeliveryTimer(address(this), seller);
        buyer = payable(msg.sender);

        buyerDeposited = msg.value;
        buyerCommittedTimestamp = block.timestamp;

        string memory weiPriceString = Strings.toString(weiPrice);
        string memory data = string(
            abi.encodePacked(
                sellerTradeUrl,
                "||",
                buyerTradeUrl,
                "||",
                weiPriceString
            )
        );
        factoryContract.onStatusChange(status, data);
        //emit BuyerCommitted(sellerTradeUrl, buyerTradeUrl, itemSellerAssetId);
    }

    // If automated Keeper-oracle can identify item has been successfully trade from seller to buyer, it will release here.
    function keeperNodeConfirmsTradeMade() external onlyKeeperNode {
        require(
            status >= TradeStatus.Committed,
            "Trade Status is not even Committed."
        );
        require(
            status < TradeStatus.Completed,
            "Trade Status is or more than Completed."
        );
        status = TradeStatus.Completed;
        usersContract.endDeliveryTimer(address(this), seller);
        bool success = factoryContract.removeTradeIdUsed(itemSellerAssetId);
        require(success, "didn't remove tradeId");
        (bool sent, ) = seller.call{value: buyerDeposited}("");
        require(sent, "Failure, ether not sent!");
    }

    // Keeper-oracle recognizes wrong-doing and defaults the trade.
    function keeperNodeConfirmsDefault() external onlyKeeperNode {
        require(
            status >= TradeStatus.Committed,
            "Trade Status is not even Committed."
        );
        require(
            status < TradeStatus.Completed,
            "Trade Status is or more than Completed."
        );
        status = TradeStatus.Clawbacked;
        bool success = factoryContract.removeTradeIdUsed(itemSellerAssetId);
        require(success, "didn't remove tradeId");
        (bool sent, ) = buyer.call{value: buyerDeposited}("");
        require(sent, "Failure, ether not sent!");
    }

    // Seller Confirms they have accepted the trade offer.
    function acceptTradeOffer() public onlyAddress(seller) {
        require(status == TradeStatus.Committed, "Trade Status not committed.");
        status = TradeStatus.Accepted;        
        factoryContract.onStatusChange(status, "");
        //emit StatusChange(address(this), status, '');
    }

    // Buyer Confirms they have received the item.
    function confirmReceived() public onlyAddress(buyer) {
        require(
            status == TradeStatus.Committed || status == TradeStatus.Accepted,
            "Trade Status not Committed or Accepted by seller."
        );
        status = TradeStatus.Completed;
        usersContract.endDeliveryTimer(address(this), seller);
        bool success = factoryContract.removeTradeIdUsed(itemSellerAssetId);
        require(success, "didn't remove tradeId");
        (bool sent, ) = seller.call{value: buyerDeposited}("");
        require(sent, "Failure, ether not sent!");
        //emit StatusChange(address(this), status, '');
        factoryContract.onStatusChange(status, "");
    }

    // Or Buyer/Seller opens dispute in any state.
    function openDispute(string memory _complaint)
        external
        onlyTheseAddresses(seller, buyer)
    {
        require(
            status != TradeStatus.Disputed &&
                status != TradeStatus.Resolved &&
                status != TradeStatus.Clawbacked,
            "Trade is already disputed or veridict already complete."
        );
        status = TradeStatus.Disputed;
        disputeer = msg.sender;
        disputedStatus = status;
        disputeComplaint = _complaint;
        //emit StatusChange(address(this), status, _complaint);
        factoryContract.onStatusChange(status, _complaint);
    }

    function resolveDispute(
        bool isFavourOfBuyer,
        bool giveWarningToSeller,
        bool giveWarningToBuyer,
        bool isWithValue
    ) external onlyKeepersOrNode {
        require(status == TradeStatus.Disputed, "Trade not disputed.");
        bool success = factoryContract.removeTradeIdUsed(itemSellerAssetId);
        require(success, "didn't remove tradeId");
        if (isFavourOfBuyer) {
            status == TradeStatus.Clawbacked;
            if (isWithValue) {
                (bool sent, ) = buyer.call{value: buyerDeposited}("");
                require(sent, "Failure, ether not sent!");
            }
        } else {
            status = TradeStatus.Resolved;
            if (isWithValue) {
                (bool sent, ) = seller.call{value: buyerDeposited}("");
                require(sent, "Failure, ether not sent!");
            }
        }
        if (giveWarningToSeller) {
            usersContract.warnUser(seller);
        }
        if (giveWarningToBuyer) {
            usersContract.warnUser(buyer);
        }
        //emit StatusChange(address(this), status, '');
        factoryContract.onStatusChange(status, "");
    }
}
